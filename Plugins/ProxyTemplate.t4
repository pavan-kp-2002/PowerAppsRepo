<#@ template debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ parameter type="System.String" name="Namespace" #>
<#@ proxymodel processor="ModelProcessor" name="Model" #>
<#@ codeblockmanager processor="CodeBlockManager" name="Manager" #>
<#
// ------------------------------------------------------------------------------------
// Create a file for each global optionset defined in the model. Do not use the 
// common header and footer for these files.
// ------------------------------------------------------------------------------------
foreach (var option in Model.GlobalOptionSets) {#>
<# var filename = @"GlobalEnums\" + option.DisplayName; #>
<# Manager.StartFile(filename, false, false); #>
namespace <#= Namespace #> 
{
	public partial class GlobalEnums 
	{
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Style", "IDE1006:Naming Styles")]
		public enum <#=string.Format("e{0}", option.DisplayName)#> {<#foreach(var e in option.Items){#> <#=e.DisplayName#>=<#=e.Value#>, <#}#>}
	}
}
<# Manager.EndBlock(); #>
<# 
// Set the exposed type to the generated enum type
option.SetType(string.Format("GlobalEnums.e{0}", option.DisplayName + "?")); #>
<#} // close foreach loop#>
<# 
//
// Capture common header used for all entity proxy files.
//
Manager.StartHeader(); #>
// 
// Code generated by a template.
//
using System;
using Microsoft.Xrm.Sdk;
using Microsoft.Xrm.Sdk.Client;

namespace <#= Namespace #> 
{
<# Manager.EndBlock(); #>

<# 
// ------------------------------------------------------------------------------------
// Generate a new file for each entity proxy generate the following within each file:
//	- Optionset enums for all non-global optionset fields.	
//	- Late bound field name constants.
//	- Getter and Setters for each field attribute value using appropriate type conversion
//	  between exposed and native types.
// ------------------------------------------------------------------------------------
foreach (var entity in Model.Entities) {#>
<# var filename = @"Entities\" + entity.LogicalName; #>
<# Manager.StartFile(filename); #>
	[EntityLogicalName("<#=entity.LogicalName#>")]
	public partial class <#=entity.DisplayName#> : CCLLC.CDS.Sdk.EarlyBound.EntityProxy
	{
		public const string EntityLogicalName = "<#=entity.LogicalName#>";

		public <#=entity.DisplayName#>()
			: base("<#=entity.LogicalName#>") {}

<# 
// 
//	Generate enums section if there are any non-global optionset fields.
//
if(entity.Fields.Where(f => f.Enum != null && f.Enum.IsGlobal != true).Count() > 0) { #>
		#region Local OptionSet Enumerations

		#pragma warning disable IDE1006 // Naming Styles
<# foreach (var f in entity.Fields.Where(f => f.Enum != null && f.Enum.IsGlobal != true)){ #>
		public enum <#=string.Format("e{0}", f.DisplayName)#> {<#foreach(var e in f.Enum.Items){#> <#=e.DisplayName#>=<#=e.Value#>, <#}#>}
<# 
// Set the exposed type to the generated enum type
f.Enum.SetType(string.Format("e{0}", f.DisplayName + "?")); #>
<#}#>
		#pragma warning restore IDE1006 // Naming Styles

		#endregion Local OptionSet Enumerations
<#}#>

		#region Late Bound Field Constants
	
		public class Fields
		{			
			public const string Id = "<#=entity.PrimaryKey.LogicalName#>";
<#foreach(var f in entity.Fields){#>
			public const string <#=f.DisplayName#> = "<#=f.LogicalName#>";
<#} // close foreach for generating field constants #>
		}

		#endregion Late Bound Field Constants

		[AttributeLogicalName("<#=entity.PrimaryKey.LogicalName#>")]
		public override Guid Id
		{
			get => base.Id; 
<# if(!entity.PrimaryKey.IsReadOnly) {#>
			set 
			{
				<#=entity.PrimaryKey.DisplayName#> = value;
				base.Id = value;
			}
<#}#>
		}

<# foreach(var f in entity.Fields) {#>
		[AttributeLogicalName("<#=f.LogicalName#>")]
		public virtual <#=f.Type.ExposedType#> <#=f.DisplayName#>
		{
<# 
// 
//	Create setters and getters with appropriate type conversion between the native and exposed data
//	types. Do not create setters if the field is read only.
//
switch(f.Type.ConversionType){
//
// Getter and Setter when conversion between money and decimal value is required.
//
case eConversionType.MoneyValue: #>
			get => GetPropertyValue<<#=f.Type.NativeType#>>("<#=f.LogicalName#>")?.Value; 
<# if(!f.IsReadOnly) {#>
			set => SetPropertyValue("<#=f.LogicalName#>", value is null ? null : new Money((decimal)value)); 
<#}#>
<# break;#>
<# 
// 
// Getter and Setter when conversion between optionset and enum is required
//
case eConversionType.OptionSetEnum: #>
			get => (<#=f.Type.ExposedType#>)GetPropertyValue<OptionSetValue>("<#=f.LogicalName#>")?.Value;
<# if(!f.IsReadOnly) {#>
			set => SetPropertyValue("<#=f.LogicalName#>", value is null ? null : new OptionSetValue((int)value)); 
<#}#>
<# break; #>
<# 
//
// Default Getter and Setter when no type conversion is required between the native
// type and the exposed type.
//
default:#>
			get => GetPropertyValue<<#=f.Type.ExposedType#>>("<#=f.LogicalName#>"); 
<# if(!f.IsReadOnly) {#>
			set => SetPropertyValue("<#=f.LogicalName#>", value); 
<#}#>
<# break;#>
<#} // end switch statement for getter/setter type conversion#>
		}

<#} // end foreach for field attributes #>
	}
<# Manager.EndBlock(); #>
<#} // end foreach for entitities#>

<#  
// ------------------------------------------------------------------------------------
// Generate a new file for each Sdk Message proxy generate the following within each file:
//	- 
//
//
// ------------------------------------------------------------------------------------
foreach (var message in Model.Messages) {#>
<# var requestName = message.DisplayName + "Request"; #>
<# var requestFile = @"Messages\" + requestName; #>
<# Manager.StartFile(requestFile); #>
	[RequestProxy("<#=message.SchemaName#>")]
	public partial class <#=requestName#> : OrganizationRequest
	{	
		public <#=requestName#>() 
			: base("<#=message.SchemaName#>") {}

		public <#=requestName#>(ParameterCollection collection) : this()
		{
			base.Parameters = collection;
		}

<#foreach (var field in message.RequestFields){#>
		public <#=field.Type.ExposedType#> <#=field.Name#>
		{
			get
			{
				if (!Parameters.Contains("<#=field.Name#>")) 
					return default;
				return (<#=field.Type.ExposedType#>)Parameters["<#=field.Name#>"];				
			}
			set
			{
				Parameters["<#=field.Name#>"] = value;
			}
		}
<#}#>
	}
<# Manager.EndBlock(); #>

<# var responseName = message.DisplayName + "Response"; #>
<# var responseFile = @"Messages\" + responseName; #>
<# Manager.StartFile(responseFile); #>
	[ResponseProxy("<#=message.SchemaName#>")]
	public partial class <#=responseName#> : OrganizationResponse
	{		
		public <#=responseName#>() 
			: base() {}

		public <#=responseName#>(ParameterCollection collection) : this()
		{
			base.Results = collection;
		}

<#foreach (var field in message.ResponseFields){#>
		public <#=field.Type.ExposedType#> <#=field.Name#>
		{
			get
			{
				if (!Results.Contains("<#=field.Name#>")) 
					return default;
				return (<#=field.Type.ExposedType#>)Results["<#=field.Name#>"];				
			}
			set
			{
				Results["<#=field.Name#>"] = value;
			}
		}
<#}#>
	
	}
<# Manager.EndBlock(); #>
<#} // end foreach sdk message #>


<#
// 
// Capture common footer
//
Manager.StartFooter();#>
}
<# Manager.EndBlock(); #>
<#
//
// Use code block manager to write out individual files. Do not generate any default output files.
//
Manager.Process(); #>